{"timestamp":"1626884853","author":"verdverm","description":"Generally speaking, I tried to follow the Golang model which prefers to use host APIs over the git protocol. I believe they will fall back to git if there are no APIs specified. This is for security reasons."}

{"timestamp":"1626888439","author":"b4nst","description":"\u003e Generally speaking, I tried to follow the Golang model which prefers to use host APIs over the git protocol. I believe they will fall back to git if there are no APIs specified. This is for security reasons.\r\n\r\nI was not aware of that. We need to think about how authenticating the APIs against private repositories then."}

{"timestamp":"1626891203","author":"verdverm","description":"Go falls back on git for private repos, there is special git config override for Go"}

{"timestamp":"1626891386","author":"verdverm","description":"Also, trying to keep this CUE Proposal in mind which will also be very Go like\r\n\r\nhttps://github.com/cue-lang/cue/issues/851"}

{"timestamp":"1626898339","author":"b4nst","description":"Yes, I'm actually using this for Cue projects so I'm also ðŸ’¯ to follow cue-lang/cue#851 "}

{"timestamp":"1626898803","author":"b4nst","description":"Go is using `GOPRIVATE` env var since 1.13 for private modules IIRC. Maybe we can use something similar here. For GitLab infinite nested level, I think you have to use the `.git` suffix. At least this is how I'm doing it, and the only way I know as for now.  "}

{"timestamp":"1627396825","author":"b4nst","description":"@verdverm I reverted the split and send it to its own function. This function now manage the `.git` extension so that if you set something like:\r\n\r\n```txtar\r\n-- cue.mod/module.cue --\r\nmodule: \"remote.my/owner/repo\"\r\n-- cue.mods --\r\nmodule remote.my/owner/repo\r\n\r\ncue v0.3.0\r\n\r\nrequire (\r\n  \"gitlab.com/nested/insanity/repo\" v0.0.0\r\n)\r\n\r\nreplace gitlab.com/nested/insanity/repo =\u003e gitlab.com/nested/insanity/repo.git v0.0.0\r\n```\r\n\r\n`hof mod vendor [cue]` will vendor the right repository. It's a bit verbose but not more than my go repositories.\r\n\r\nI've also added Zip download from API request for GitLab, in a way it has been done by you for GitHub.\r\n\r\nNow if that changes are ok with you, what I would want to do is to clean that a little bit, rely on `netrc` (with a fallback on plain git ssh) instead of some magic env var for private repositories. And detect private repositories from the `GOPRIVATE` environment variable. We'll have to decide if we go for plain git if the remote is GitHub or GitLab, or stay with the APIs and use the password extracted from netrc as token. If we do the former, we can safely drop the bit of code extracting auth from `os.Getenv` in the `yagu/repos/*`. I think go is doing plain git for private repository, not 100% sure tho"}

{"timestamp":"1627415032","author":"verdverm","description":"I'm not keen to rely on a `GO...` env var for all modders. Perhaps some of this per language / code host settings can be put in the modder config / schema? What do you think?"}

{"timestamp":"1627415625","author":"verdverm","description":"Thinking about auth, what are the various scenarios? How would this work in a CI system that might be different than local dev? (Do all the major CI systems rely on sshkeys to fetch private code?)"}

{"timestamp":"1627418522","author":"b4nst","description":"I think a `netrc` fallbacking to an `ssh` auth would give enough flexibility to tackle every systems without overthinking it. We could also implementing some sort of dynamic env, but in the end it's quite common to just echo the env in the netrc file for CI systems."}
